<aside>
💡 파티션을 이용하면 대량 추가 / 변경 / 삭제 작업을 처리할 수 있다.

</aside>

### 테이블 파티션

---

파티셔닝은 테이블, 인덱스 데이터를 특정 컬럼 값에 따라 별도 세그먼트에 나눠서 저장하는 것을 말한다.

관리적 측면: 파티션 단위 백업, 추가, 삭제, 변경 → 가용성 향상

성능적 측면: 파티션 단위 조회 및 DML, 경합 또는 부하 분산

**성능적으로 좋은 이유**

pruning(불필요한 부분 제거) 때문이다.

SQL 하드파싱이나 실행 시점에 조건절을 분석해서 읽지 않아도 되는 파티션 세그먼트를 액세스 대상에서 제외하는 기능이다.

**range 파티션**

주로 날짜 컬럼을 기준으로 파티셔닝한다.

- 이력성 데이터를 full scan 방식으로 조회할 때 성능이 크게 향상
- 전체가 아닌 일부 파티션 세그먼트만 읽고 멈출 수 있어 성능을 크게 향상시킨다.

**해시 파티션**

파티션 키 값을 해시함수에 입력해서 반환받은 값이 같은 데이터를 같은 세그먼트에 저장하는 방식

- 주로 고객 ID 처럼 변별력이 좋고 데이터 분포가 고른 컬럼을 파티션 기준으로 선정한다.

**리스트 파티션**

사용자가 정의한 그룹핑 기준에 따라 데이터 분할 저장

- range 파티션에선 값의 순서에 따라 저장할 파티션이 결정되지만 순서와 상관없이 불연속적인 값의 목록에 의해 결정된다.

### 인덱스 파티션

---

로컬 파티션 인덱스, 글로벌 파티션 인덱스, 비파티션 인덱스가 있다.

**로컬 파티션 인덱스**

각 테이블 파티션과 인덱스 파티션이 서로 1:1 대응관계가 되도록 오라클이 자동으로 관리하는 파티션 인덱스

- `create index ... LOCAL`
- 인덱스 파티션은 테이블 파티션 속성을 그대로 상속받는다.

**글로벌 파티션 인덱스**

로컬 파티션 인덱스가 아닌 파티션 인덱스

- 파티션 테이블과 다르게 구성한 인덱스
    - 파티션 키가 다름
    - 파티션 유형이 다름
    - 파티션 기준값 정의가 다름
- `create index ... GLOBAL`
- 글로벌 파티션 인덱스는 테이블 파티션 구성을 변경하는 순간 unusable이므로 인덱스를 재생성해줘야한다.

**비파티션 인덱스**

파티셔닝하지 않은 인덱스 ⇒ 일반 인덱스

- 테이블 파티션 구성을 변경하는 순간 unusable 상태로 바뀌므로 곧바로 인덱스를 재생성해줘야한다.

**Prefixed , Nonprefixed**

prefixed: 인덱스 파티션 키 컬럼이 인덱스 키 컬럼 왼쪽 선두에 위치한다.

nonprefixed: 인덱스 파티션 키 컬럼이 인덱스 키 컬럼 왼쪽 선두에 위치하지 않는다. 파티션 키가 인덱스 컬럼에 속하지 않을 경우

**중요한 인덱스 파티션 제약**

`unique 인덱스를 파티셔닝하려면, 파티션 키가 모두 인덱스 구성 컬럼이여야한다.`

예시

- PK 인덱스가 주문번호 단일컬럼이다.
- 파티션 키가 주문일자이다.

이 상태에서 주문번호가 123456인 주문 레코드를 입력하려면?

⇒ 인덱스는 주문번호이지만 주문일자로 파티셔닝이 되어 있기 때문에 모든 파티션을 검색해야한다.

하지만 만약 파티션 키가 주문번호라면?(파티션 키가 모두 인덱스 구성 컬럼이라면?)

⇒ 특정 파티션만 조회하면 된다.

**즉 파티션 키가 인덱스 구성 컬럼이 아닌 상황에서의 문제점**

- 모든 파티션을 조회해야한다.
- 다른 파티션에 입력하는 현상을 막으려는 추가적인 Lock 메커니즘이 필요하다.
- 파티션 drop, truncate, exchange, split, merge 등 파티션 구조 변경 작업도 쉽지 않다.
- 위와 같은 작업을 하는 동안 pk 인덱스가 unusable 상태로 변경되어 테이블 사용을 중단해야한다.

### 파티션을 활용한 대량 update

---

대량의 데이터가 있다면 업데이트하는데 시간이 오래걸린다. 그리고 drop 했다가 재생성하는게 더 좋을지 고민해봐야한다. ⇒ exchange를 이용한 대량 데이터 변경

**파티션 Exchange를 이용한 대량 데이터 변경**

수정된 값을 갖는 임시 세그먼트를 만들어 원본 파티션과 바꿔치기하는 방식이다.

1. 임시 테이블 생성 ⇒ 가능하다면 nologging
2. 데이터를 읽어 임시 테이블에 입력하면서 상태코드 값을 수정
3. 임시 테이블에 원본 테이블과 같은 구조로 인덱스 생성
4. 파티션 테이블과 임시 테이블을 exchange
5. 임시 테이블 drop

### 파티션을 활용한 대량 DELETE 튜닝

---

인덱스 삭제하는데도 오래걸린다.

**delete가 느린 이유**

1. 테이블 레코드 삭제
2. 테이블 레코드 삭제에 대한 undo logging
3. 테이블 레코드 삭제에 대한 redo logging
4. 인덱스 레코드 삭제
5. 인덱스 레코드 삭제에 대한 undo logging
6. 인덱스 레코드 삭제에 대한 redo logging

**파티션 drop**

조건: 삭제 조건절 컬럼 기준으로 파티셔닝돼 있고 인덱스도 같다면? ⇒ 파티션 삭제

**파티션 truncate를 이용한 삭제**

1. 임시 테이블 생성 - 남길 데이터만 복제
2. 파티션을 truncate
3. 파티션 지정
4. 임시 테이블에 복제해 둔 데이터를 원본 테이블에 입력
5. 임시 테이블 drop

**서비스 중단 없이 파티션 drop, truncate 조건**

1. 파티션 키와 커팅 기준 컬럼 일치
2. 파티션 단위와 커팅 주기가 일치
3. 모든 인덱스가 로컬 파티션 인덱스여야함

### 파티션 활용한 대량 insert

---

**unusable 시켰다가 재생성하는 방식**

**테이블이 파티셔닝돼있고 인덱스도 로컬 파티션이라면 파티션 단위로 인덱스 재성성 가능**

1. 테이블 파티션과 매칭되는 인덱스 파티션을 unusable 상태로 전환
2. 대량 데이터 입력
3. 인덱스 파티션 재생성