### 부분범위 처리

---

DBMS가 클라이언트에게 데이터를 전송할 때 일정량씩 나누어 전송한다.
전송한 후에 fetch call이 있기 전까지 기다린다.

**1억건짜리 테이블인데도 결과를 빨리 출력할 수 있는 이유**

- 한번에 데이터를 모두 읽어 전송하지 않고 먼저 읽는 데이터부터 일정량을 전송하고 멈추기 때문이다.
- fech call을 받으면 대기 큐에서 나와 그 다음 데이터부터 일정량을 읽어서 전송하고 또다시 잠을 잔다.

⇒ 부분 범위 처리 - 약간 페이징하고 원리가 비슷한듯

### 정렬 조건이 있을 때 부분 범위 처리

---

```sql
select * from user order by created
```

**인덱스가 안되어 있다면?**

- 모든 데이터를 읽고 created 순으로 정렬
- 데이터 전송

**인덱스가 되어 있다면?**

- 이미 정렬되어 있으므로 부분범위 처리가 가능하다.

### array size 조절을 통한 fetch call 최소화

---

대량의 데이터 파일

size를 크게 해서 fetch call 횟수를 줄임

소량의 데이터 파일

size를 줄여 불필요하게 많은 데이터를 전송하고 버리는 비효율을 줄일 수 있기 때문

### 배치 I/O

---

배치 I/O는 읽는 블록마다 건건이 I/O call을 발생시키는 비효율을 줄이기 위해 고안한 기능

- 인덱스를 이용해 테이블을 액세스하다가 버퍼 캐시에서 블록을 찾지 못하면 일반적으로 디스크 블록을 바로 읽는데, 이 기능이 작동하면 테이블 블록에 대한 디스크 I/O call을 미뤘다가 읽을 블록이 일정량 쌓이면 한꺼번에 처리
- 하지만 배치 I/O 기능이 작동하면 인덱스를 이용해서 출력하는 데이터 정렬 순서가 매번 다를 수 있다.
- 테이블 블록을 모두 버퍼 캐시에서 찾을 때는 키값 순으로 출력 (히트율 100%)
- 모두 버퍼캐시에서 찾는게 아니라면 순서가 다를 수 있음 (히트율 100% 미만)

⇒ 인덱스 정렬 순서를 믿고 order by를 생략하는 개발 패턴은 사용되면 안된다.!!