## 부분 범위 처리 활용

**부분 범위 처리**

- DBMS가 클라이언트에게 데이터를 전송할 때 일정량씩 나누어 전송한다
- 전체 결과집합 중 아직 전송하지 않은 분량이 많이 남아있어도 서버 프로세스는 클라이언트로부터 추가 Fetch Call를 받기 전까지 그대로 멈춰 서서 기다린다
- OLTP환경에서 대용량 데이터를 빠르게 핸들링할 수 있는 아주 중요한 원리가 여기에 숨어있다
- DBMS가 데이터를 모두 읽어 한 번에 전송하지 않고 머너 읽는 데이터부터 일정량(Array Size)을 전송하고 멈추기 때문이다 데이터를 전송하고 나면 서버 프로세스는 CPU를 OS에 반환하고 대기 큐에서 잠을 잔다 다음 Fetch Call을 받으면 대기 큐에서 나와 그다음 데이터부터 일정량을 읽어서 전송하고 또다시 잠을 잔다
- 이처럼 전체 쿼리 결과집합을 쉼 없이 연속적으로 전송하지 않고 사용자로부터 Fetch Call이 있을 때마다 일정량씩 나누어 전송하는 것을 이른바 '부분범위 처리'라고 한다
- 데이터를 전송하는 단위인 Array Size는 클라이언트 프로그램에서 설정한다 JAVA에서 Array Size 기본값은 10이며, Statement 객체 setFetchSize 메소드를 통해 설정을 변경할 수 있다 Array Size가 10인 상태에서 위 JAVA 프로그램이 데이터를 읽어 들이는 메커니즘은 다음과 같다
    1. 최초 rs.next() 호출 시 Fetch Call을 통해 DB 서버로부터 전송받은 데이터 10건을 클라이언트 캐시에 저장한다
    2. 이후 rs.next() 호출할 때는 Fetch Call을 발생시키지 않고 캐시에서 데이터를 읽는다
    3. 캐시에 저장한 데이터를 모두 소진한 상태에서 rs.next() 호출 시 추가 Fetch Call을 통해 10건을 전송받는다
    4. 100건을 다 읽을 때까지 2~3번 과정을 반복한다

**정렬 조건이 있을 때 부분 범위 처리**

- `select name from big_table order by created`
    - created 컬럼이 선두인 인덱스가 있으면, 부분범위 처리가 가능하다
    - 인덱스는 항상 정렬된 상태를 유지하므로 전체 데이터를 정렬하지 않고도 정렬된 상태의 결과집합을 바로 전송할 수 있기 때문이다

**Array Size 조정을 통한 Fetch Call 최소화**

대량 데이터를 파일로 내려받는다면 어차피 데이터를 모두 전송해야 하므로 가급적 그 값을 크게 설정해야 한다. Array Size를 조정한다고 해서 전송해야 할 총량이 변하진 않지만, Fetch Call 횟수를 그만큼 줄일 수 있다.

반대로, 앞쪽 일부 데이터만 Fetch하다가 멈추는 프로그램이라면 Array Size를 작게 설정하는 것이 유리하다. 불필요하게 많은 데이터를 전송하고 버리는 비효율을 줄일 수 있기 때문이다. (방금 본 JAVA 프로그램에서 만약 Array Size를 1,000으로 설정한다면, 사용하지도 않고 버릴 뒤쪽 900개 레코드를 읽어서 전송하는 과정에 네트워크와 서버, 클라이언트 자원만 낭비하게 된다.)

**데이터 정렬 이슈**

배치 I/O 기능이 작동하면 인덱스를 이용해서 출력하는 데이터 정렬 순서가 매번 다를 수 있다는 사실에 주목해야 한다. 테이블 블록을 모두 버퍼 캐시에서 찾을 때는(버퍼캐시 히트율 = 100%) 즉, 실제 배치 I/O가 작동할 때는 데이터 출력 순서가 인덱스 정렬 순서와 다를 수 있다
