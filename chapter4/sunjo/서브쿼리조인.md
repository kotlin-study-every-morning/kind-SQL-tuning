<aside>
💡 서브 쿼리 조인을 어떻게 처리하는지 이해

</aside>

### 서브쿼리 변환이 필요한 이유

---

옵티마이저는 전달받은 SQL을 최적화에 유리한 형태로 변환하는 작업을 먼저 시작한다.

**쿼리 변환**이란 옵티마이저가 의미적으로 동일하면서도 더 나은 성능이 기대되는 형태로 재작성하는 것을 말한다.

서브쿼리는 세가지로 분류한다. - 스칼라 서브쿼리, 인라인 뷰, 중첩 서브쿼리

**스칼라 서브쿼리**

한 레코드당 한하 의값 을을을 하서 브쿼

**인라인 뷰**

from 절에서 사용한 서브쿼리

**중첩된 서브쿼리**

where절에서 사용한 서브쿼리

⇒ 메인 쿼리도 하나의 쿼리 블록이며 옵티마이저는 쿼리 블록 단위로 최적화한다.

아래 처럼 각각 최적화

```sql
select * from 고객 c where ... and exists (select 'x' from 거래 where 고객번호 = c.고객번호)

// 1
select * from 고객 where...

// 2
select 'x' from 거래..

```

하지만 각각 최적화 됐다고 해서 전체적으로 최적화 됐다고 할 수 없다.

### 서브 쿼리와 조인

---

서브쿼리는 단독으로 실행되지 않는다.

메인 쿼리 건수만큼 값을 받아 반복적으로 필터링하는 방식으로 실행한다.

**필터 오퍼레이션**

기본적으로 NL 조인과 처리 루틴이 같다.

차이점

1. 메인쿼리의 한 로우가 서브쿼리의 한로우와 조인에 성공하는 순간 진행을 멈추고, 메인쿼리의 다음 로우를 계속 처리한다.
2. 필터는 캐싱기능을 갖는다. - 항상 캐시부터 확인
3. 메인 쿼리에 종속되므로 조인 순서가 고정

**서브쿼리 unnesting**

unnesting은 메인과 서브쿼리 간의 계층구조를 풀어 서로 같은 레벨로 만들어 준다는 의미 = 서브쿼리 flattening

unnesting을 하면 일반 조인문처럼 다양한 최적화 기법 사용 가능

**NL 세미 조인**

조인에 성공하는 순간 진행을 멈추고 메인 쿼리의 다음 로우를 계속 처리한다.

**ROWNUM - 잘 쓰면 약, 잘못 쓰면 독**

- exists 서브쿼리에 rownum 조건을 사용하면 의미의 중복이 된다.
- 서브쿼리에 rownum을 쓰면 중요한 옵티마이저 기능을 사용하지 못하게 막는 효과가 있다.

**서브쿼리 pushing**

- 서브쿼리 필터링을 가능한 한 앞 단계에서 처리하도록 강제하는 기능
- unnesting 되지 않은 서브쿼리에서만 작동
- push_subq 힌트는 항상 no_unnest와 같이 기술

### 뷰와 조인

---

뷰 쿼리를 변환하지 않으면 뷰 쿼리 블록을 독립적으로 최적화한다.

단점

- 조인에 성공한 전체 집합을 group by 하고서야 데이터를 출력할 수 있다 ⇒ 부분범위 처리가 불가능하다.

**조인 조건 pushdown**

메인 쿼리를 실행하면서 조인 조건절 값을 건건이 뷰 안으로 밀어 넣는 기능

- 건건이 당월 거래 데이터만 읽어서 조인하고 group by를 수행한다. ⇒ 부분범위 처리가 가능

### 스칼라 서브쿼리 조인

---

메인쿼리 레코드마다 정확히 하나의 값만 반환

- 함수와 비슷해보이지만 재귀적으로 실행하는 구조는 아님 ⇒ 컨텍스트 스위칭 없이 메인 쿼리와 서브 쿼리를 한 몸체처럼 실행
- 스칼라 서브쿼리는 처리 과정에서 캐싱 작용이 일어남

**캐싱 효과**

조인 횟수를 최소화하려고 입력 값과 출력 값을 내부 캐시에 저장한다.

- 필터 서브쿼리 캐싱과 같은 기능이다.. ⇒ 조인 성능을 높이는데 큰 도움이 된다.
- 캐싱은 쿼리 단위로 이루어진다. ⇒ 쿼리 시작시 PGA 메모리에 공간을 할당하고 쿼리 종료시 반환

튜닝 기법

- select-list에 사용한 함수는 메인쿼리 결과 건수만큼 반복 수행하는데 스칼라 서브쿼리를 덧씌우면 호출 횟수를 최소화할 수 있다.

**캐싱 부작용**

- 해시 충돌 가능성이 작을 떄 효과가 있다.
- 해시 충돌이 크다면 캐시를 매번 확인하는 비용 때문에 성능이 나빠지고 cpu, memory 사용률이 높아진다.

**두개 이상 값 반환**

- 구하는 값들을 문자열로 모두 결합하고, 바깥쪽 액세스 쿼리에서 substr 함수로 다시 분리하는 방식을 튜닝방식으로 많이 사용한다. ⇒ 하지만 불편하기 때문에 잘 쓰이지 않음
- 그래서 인라인 뷰를 사용하면 편하긴 하다. ⇒ 하지만 전체를 읽거나 부분범위 처리가 안되는 문제가 있다.

**서브쿼리 unnesting**

- 스칼라 서브쿼리도 NL 방식으로 조인하므로 캐싱 효과가 크지 않으면 랜덤 IO 부담이 있다.
- 병렬 쿼리에선 스칼라 서브쿼리를 사용하지 않아야한다.