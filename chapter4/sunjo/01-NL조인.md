### 기본 메커니즘

---

인덱스를 이용한 조인

```sql
select * from 사원 e, 고객 c
where e.입사일자 >= '19960101'
and c.관리사원번호 = e.사원번호
```

⇒ 사원 테이블로부터 1월1일 이후에 입사한 회원을 찾아 고객 테이블에서 사원번호가 일치하는 레코드를 찾는다.

- 일반적으로 outer, inner 양쪽 테이블 모두 인덱스를 사용한다.
- outer 테이블은 사이즈가 크지 않으면 인덱스를 이용하지 않을 수 있다. ⇒ full scan 하더라도 한 번에 그치기 때문이다.
- 반면 inner 테이블은 인덱스를 사용해야한다. ⇒ outer에서 읽은 건수만큼 읽어야하기 때문에

**과정**

1. 입사일자 ≥ ‘19960101’ 인 레코드를 찾는다.
2. 인덱스에서 읽은 rowid로 사원 테이블 레코드를 찾아간다.
3. 사원테이블에서 읽은 값으로 X1 인덱스를 탐색한다.(사원번호 0006)
4. X1 인덱스에서 읽은 rowid로 고객 테이블을 찾아간다.
5. X1 인덱스에서 한 건 더 스캔하고 관리사원번호가 조건이 0006이 맞는지 확인한다.
6. rowId로 고객 테이블을 찾아간다.

위와 같은 과정 반복

### NL 조인 수행 과정 분석

```sql
select * from 사원 e, 고객 c
where e.입사일자 >= '19960101' - 1
and c.관리사원번호 = e.사원번호   - 2
and e.부서코드 = 'z123'        - 3
and c.최종구문금액 >= 20000     - 4
```

인덱스 구성

- 사원번호
- 입사일자
- 고객번호
- 관리사원번호
- 최종주문금액

조건절 비교 순서로 나열하면 2 - 3 - 1 - 4

1. 만족하는 레코드를 찾기 위해 사원_X1을 스캔
2. 사원_X1 인덱스에서 읽은 rowId로 사원 테이블을 액세스 해서 부서코드 필터링
3. 사원테이블에서 읽은 값으로 조인조건에 만족하는 고객쪽 레코드를 찾기 위해 고객_X1을 스캔
4. 필터 조건

**튜닝 포인트**

- 만약 위에 1번에서 사원 테이블로 많은 랜덤 액세스가 발생했고 부서코드 ‘Z123’에 필터링 되는 비율이 높다면? ⇒ 사원_X1에 부서 코드 컬럼을 추가하는 방안을 고려
- 만약 부서코드 =’Z123’인 값이 많다면 조인 액세스 횟수가 많아져 성능이 느려짐
- 고객_X1을 읽고 고객 테이블을 액세스 하는 부분이 많다면? ⇒ 최종주문금액 컬럼을 추가
- 사원_X1 인덱스에서 얻은 결과 건수에 의해 전체 일량이 좌우된다

### 결론

- nl조인은 랜덤 액세스 위주의 조인이다. ⇒ 수행 일량을 분석해서 과도한 랜덤 액세스가 발생하는 지점을 파악해야한다.
- 조인을 한 레코드씩 순차적으로 진행한다.
- 결국 인덱스 구성 전략이 중요하다.
- nl 조인은 온라인 트랜잭션 처리(OLTP) 시스템에 적합하다.

### 문제

---

```sql
select * from 사원 e, 고객 c
where e.입사일자 >= '19960101' 
and c.관리사원번호 = e.사원번호   
and e.부서코드 = 'z123'        
and c.최종구문금액 >= 20000
```

```sql
# trace
nested loops                        - 5
table access by index rowid of 사원  - 3
index range scan of 사원_X1          - 2780
table access by index rowid of 고객  - 5
index range scan of 고객_X1          - 8
```

인덱스 구성

- 사원번호
- 입사일자
- 고객번호
- 관리사원번호
- 최종주문금액
- 답

  인덱스 스캔하고 액세스 횟수 2780, 부서코드 필터링 결과가 세건
  ⇒ 불필요한 테이블 인덱스

  ⇒ 액세스 한 후 필터링 되는 비율이 높다면 인덱스에 테이블 필터 조건 컬럼 추가를 고려


```sql
# trace
nested loops(cr=112 pr=34...)            5
table access by index rowid of 사원(cr=105 pr=32...) 3
index range scan of 사원_X1(cr=102 pr=31...) 3 
table access by index rowid of 고객(cr=7 pr=2...) 5
index range scan of 고객_X1(cr=5 pr=1...) 8
```

- cr = 논리적인 블록  요청 횟수
- pr = 디스크에서 읽은 블록 수
- 답

  사원_X1 인덱스로부터 읽은 블록이 102개. 한블록당 500이라하면 - 50000개 레코드 읽음


```sql
# trace
nested loops(cr=2732 pr=386...)            5
table access by index rowid of 사원(cr=166 pr=2...) 2780
index range scan of 사원_X1(cr=4 pr=0...) 2780
table access by index rowid of 고객(cr=2566 pr=384...) 5
index range scan of 고객_X1(cr=2558 pr=383...) 8
```

- 답
    - 사원테이블은 괜찮음
    - 고객테이블 조인하는 횟수가 문제. 2780을 조인했는데 성공은 5개뿐
    - 조인 순서 변경을 고려해볼수도 있고 다른방법을 찾아볼 수도 있다.

### NL 조인 확장 메커니즘

---

테이블 prefetch는 테이블을 액세스하다가 디스크 IO가 필요해지면 이어서 곧 읽게 될 블록까지 미리 읽어서 버퍼캐시에 적재하는 기능