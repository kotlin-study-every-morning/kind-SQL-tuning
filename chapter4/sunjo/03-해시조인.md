### 기본 메커니즘

---

1. build
    1. 작은 쪽 테이블을 읽어 해시 테이블(해시 맵)을 생성한다.
2. probe
    1. 큰쪽 테이블을 읽어 해시 테이블을 탐색하며 조인한다.

```sql
select * from 사원 e, 고객 c
where e.입사일자 >= '19960101' 
and c.관리사원번호 = e.사원번호   
and e.부서코드 = 'z123'        
and c.최종구문금액 >= 20000
```

1. build - 사원 데이터를 읽어 해시 테이블 생성 (사원테이블이 적음) - 조인 컬럼인 사원번호를 해시 테이블 키 값으로 사용, 해시 테이블은 PGA 영역에 할당된 hash area에 저장
2. probe - 고객 데이터를 하나씩 읽어 앞서 생성한 해시 테이블을 탐색(같은 사원 번호를 입력하면 같은 해시 값을 반환)

### 빠른 이유

---

참고로 해시테이블에는 키값뿐만 아니라 SQL에 사용한 컬럼을 모두 저장한다.
만약 키값 말고 다른 값들을 저장하지 않는다면 나머지 값들을 얻기 위해서 다시 테이블 블록에 액세스 해야하기 때문이다.

- 해시 테이블을 PGA 영역에 할당하기 때문이다. 해시 조인은 래치 획득 과정 없이 PGA에서 빠르게 데이터를 탐색하고 조인한다.
- 랜덤 액세스 부하가 없고 양쪽 집합을 미리 정렬하는 부하도 없다.

### 대용량 Build input

---

DBMS는 어떤 방식으로 해시 조인을 처리할까? - 분할, 정복 방식이다.

1. 파티션 단계 - 해시 값에 따라 동적으로 파티셔닝
2. 조인 단계 - 각 파티션 짝에 대해 하나씩 조인을 수행한다.

### 세 개 이상 테이블 해시 조인

---

```sql
select * 
from A, B, C
where A.key = B.key
and B.key = C.key
```

```sql
select * 
from A, B, C
where A.key = B.key
and A.key = C.key
```

결국 세 테이블 조인 경로는 t1 ↔ t2 ↔ t3가 된다.

### 조인 메서드 선택 기준

---

해시조인 처리하는데 수행빈도가 매우 높은 쿼리에 대해서 조심해야한다.

1. 소량의 데이터 조인 - NL 조인
2. 대량 조인 - 해시 조인
3. 대량 데이터인데 해시 조인을 사용하지 못할 경우, =이 아닐 경우 - 소트 머지 조인

대량과 소량은 데이터량이 아니라 nl조인 기준으로 ‘최적화했는데도’ 랜덤 액세스가 많아 만족할만한 성능을 낼 수 없다면 대량 조인에 해당한다.

그리고 수행 빈도가 높은 쿼리에 대한 기준

1. nl조인과 해시 조인 성능이 같다면? - nl 조인
2. 해시 조인이 약간 더 빨라도 - nl조인
3. nl조인보다 해시조인이 매우 빠른 경우(대량 데이터) - 해시 조인

**왜 NL 조인을 먼저 고려할까?**

- nl조인에 사용하는 인덱스는 영구적으로 유지하면서 다양한 쿼리를 위해 공유 및 재사용하는 자료구조이다.
- 해시테이블은 단 하나의 쿼리를 위해 생성하고 조인이 끝나면 곧바로 소멸하는 구조이다.
    - 해시 테이블 많이 만듦 → cpu, 메모리 사용률 증가 등이 발생