<aside>
💡 네비게이션과 비교하면서 옵티마이저에 대한 이해를 넓혀보자

</aside>

### 옵티마이저 종류

---

**비용 기반 옵티마이저(CBO)**

데이터 딕셔너리에 미리 수집해 둔 통계정보를 이용해 각 실행계획의 예상비용을 산정

**CBO가 사용하는 통계 정보**

테이터량, 컬럼 값의 수, 컬럼 값 분포, 인텍스 높이, 클러스터링 팩터 등

**규칙 기반 옵티마이저(RBO)**

- 통계 정보를 활용하지 않고 단순한 규칙에만 의존하기 때문에 대량 데이터를 처리하는데 부적합
- RBO는 무조건 인덱스를 사용
    - 하지만 데이터양이 많을 경우 부적합 ⇒ CBO가 탄생하게됨

### 옵티마이저 모드

---

**ALL_ROWS - 전체 처리속도 최적화**

- 전체를 읽는 것으로 전제로 시스템 리소스를 가장 적게 사용하는 실행계획 선택

**FIRST_ROWS - 최초 응답속도 최적화**

- 앞쪽 일부만 읽다가 멈추는 것을 전제로 속도가 가장 빠른 실행계획을 선택
- 사라지게 될 모드여서 사용X

**FIRST_ROWS_N - 최초 N건 응답속도 최적화**

- 앞쪽 N개 로우만 읽고 멈춤을 전제로 가장 빠른 실행계획을 선택

### 옵티마이저에 영향을 미치는 요소

- SQL 연산자 형태
- 인덱스, IOT, 클러스터, 파티션, MV 등 옵티마이징 팩터
- 제약 설정
- 통계정보
- 옵티마이저 힌트
- 옵티마이저 관련 파라미터

### 옵티마이저의 한계와 개선해야할 점

---

보편적으로 좋은 선택을 하지만 그 선택이 항상 최선은 아니다.

⇒ 그렇기 때문에 개발자가 옵티마이저가 되어야한다.

⇒ 결과물이 올바른지 매번 실행계획을 점검, 개선해야한다.

### **SQL 성능을 높이기 위해 개발자가 할 일**

---

**필요한 최소 블록만 읽도록 쿼리를 작성한다.**

**최적의 옵티마이징 팩터를 제공한다.**

옵티마이저는 주어진 환경에서 가장 빠른 처리 경로를 찾아주는 것 - 고로 인덱스, 파티션, 클러스터는 개발자가 잘~ 걸어야한다.

- 전략적인 인덱스 구성
- DBMS가 제공하는 다양한 기능 활용 - IOT, 파티션, 클러스터 등등
- 옵티마이저 모드 설정
- 정확하고 안정적인 통계 정보

**옵티마이저 힌트를 사용해 최적의 액세스 경로로 유도한다.**

- 참고

  [https://hoing.io/archives/2195](https://hoing.io/archives/2195)