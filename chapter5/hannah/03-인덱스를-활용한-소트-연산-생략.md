### 인덱스를 이용한 소트 연산 생략

**Sort Order By 생략**

- 부분 범위 처리를 활용한 튜닝 기법, 아직도 유효한가?
    - 지금까지 부분범위 처리 원리를 여러 곳에서 강조해 왔고, 방금도 그랬다
    - 부분 범위 처리는 쿼리 수행 결과 중 앞쪽 일부를 우선 전송하고 멈추었다가 클라이언트가 추가 전송을 요청할 때 마다 남은 데이터를 조금씩 나눠 전송하는 방식을 말한다
    - 부분범위 처리 활용은
        1. 결과집합 출력을 바로 시작할 수 있느냐
        2. 앞쪽 일부만 출력하고 멈출 수 있느냐
    - 가 핵심이다
    - 부분 범위 처리 원리는 3-Tier 환경에서 여전히 유효하다
    - 비밀은 Top N 쿼리에 있다

**Top N 쿼리**

- Top N 쿼리 : 전체 결과 집합 중 상위 N개 레코드만 선택하는 쿼리
- 사용 : mysql 에서는 limit
- 조건절에 부합하는 레코드가 아무리 많아도 그 중 ROWNUM으로 지정한 건수만큼 결과 레코드를 얻으면 거기서 바로 멈춘다는 뜻
- 페이징 처리
    - 3-Tier 환경에서는 대량의 결과 집합을 조회할 때 페이징 처리 기법을 활용한다
    - 일반적으로 사용하는 표준 패턴

    ```sql
    select *
    from (
    	select rownum no, a.*
    	from ( /* sql */ ) a
    	where rownum <= (:page * 10)
    )
    where no >= (:page - 1) * 10 + 1;
    ```

    - 3-Tier 환경에서 부분범위 처리를 활용하기 위해 할 일
        1. 부분범위 처리 가능하도록 SQL을 작성한다 부분범위 처리가 잘 작동하는지 토드, 오렌지 같은 쿼리 툴에서 테스트한다
           ( → 인덱스 사용하능하도록 조건절 구사, 조인은 NL 조인 위주로, Order By 절이 있어도 생략 가능하도록 구성 p.358에 예제 있음)
        2. 작성한 SQL 문을 페이징 처리용 표준 패텅 SQL Body 부분에 부어 넣는다
- 페이징 처리 ANTI 패턴
    - ROWNUM은 단순한 조건절이 아니다
    - 지금까지 설명한  ‘Top N Stopkey’ 알고리즘을 작동하게 하는 열쇠다
    - 코드를 간결하게 하고 싶어 ROWNUM을 사용하지 않으면 실행계획이 바뀐다 (full scan)


**최소값/최대값 구하기**

- 인덱스 이용해 최소/최대값 구하기 위한 조건
    - 전체 데이터를 읽지 않고 인덱스를 이용해 최소 또는 최대갑승ㄹ 구하려면, 조건절 컬럼과 MIN/MAX 함수 인자 컬럼이 모두 인덱스에 포함돼 있어야 한다
    - 즉, 테이블 액세스가 발생하지 않아야 한다
    - First Row Stopkey 알고리즘 : 조건을 만족하는 범위(Range) 가장 오른쪽에 있는 값 하나를 읽고 바로 멈춘다
- Top N 쿼리를 이용하 최소/최대값 구하기

    ```sql
    select * 
    from (
    	select sal
    	from emp
    	where no = 30
    	and mrg = 2441
    	**order by sal desc**
    )
    **where rownum <= 1;**
    ```


**이력 조회**

- 가장 단순한 이력 조회
    - 이력 데이터 조회할 때 ‘First Row Stopkey’ 또는 ‘Top N Stopkey’ 알고리즘이 작동할 수 있게 인덱스 설계 및 SQL 구현하는 일은 고급 SQL 튜너가 되기 위해 반드시 정복해야할 산이다
    - 이력 조회 : 히스토리 테이블을 조회하는 것
- 점점 복잡해지는 이력 조회
    - 인덱스 컬럼을 가공하면 ‘First Row Stopkey’ 알고리즘이 작동하지 않는다
    - 컬럼이 점점 복잡해지면 사용할 수 있는 힌트가 있다
- INDEX_DESC 힌트 활용
    - 튜닝 전문가들이 전통적으로 사용해 온 방식
        - 인덱스를 역순으로 읽도록 index_Desc 힌트를 사용, rownum ≤ 1 조건절 사용(첫 번째 레코드에서 바로 멈출 수 있도록)
    - 인덱스 구성이 바뀌면 언제든 결과집합에 문제가 생길 수 있다
    - PK 구성을 변경하는 일은 거의 없으므로 대개 문제가 되지 않는다고 볼 수 있지만, 다른 대안이 있다면 그 방법을 사용하는게 바람직
- 상황에 따라 달라져야하는 이력 조회 패턴
    - 본 절의 주제가 ‘인덱스를 이용한 소트 연산 생략’이므로 ‘First Row Stopkey’ 또는 ‘Top N Stopkey’ 알고리즘이 작동할 수 있게 SQL을 작성하는 중심으로 살펴봤지만, 상황에 따라 이력 조회 패턴도 달라야한다
    - 대량 데이터를 조회할 때 ‘인덱스 손익분분기점’ 후반부에 설명한 온라인 프로그램과 배치 프로그램 튜닝의 특징을 상기하기 바란다
- 선분이력 맛보기
    - 선분리역 모델을 채택하면, 어떤 상황에서든 아래와 같이 간단한 쿼리로 쉡게 이력을 조회할 수 있고, 쿼리가 간단한 만큼 성능 측면에 이점도 생긴다
    - [https://moons08.github.io/programming/history_management/](https://moons08.github.io/programming/history_management/)

**Sort Group By 생략**

- 인덱스를 이용해 소트 연산을 생략할 수 있다는 사실은 많이 알려졌고 이해하기도 비교적 쉽다
- 반면, 그룹핑 연산에도 인덱스를 활용할 수 있다는 사실은 모르는 분이 많다
- 과정
    1. 인덱스에서 ‘A’ 구간을 스캔하면서 테이블을 액세스하다가 ‘B’를 만나는 순간, 그때까지 집계한 값을 운반단위에 저장한다
    2. 계속해서 ‘B’ 구간을 스캔하다가 ‘C’를 만나는 순간, 그때까지 집계한 값을 운반단위에 저장한다
    3. 계속해서 ‘C’ 구간을 스캔하다가 ‘D’를 만나는 순간, 그때까지 집계한 값을 운반단위에 저장한다 Array Size가 3이므로 지금까지 읽은 A, B, C에 대한 집계결과를 클라이언트에게 전송하고 다음 Fetch Call이 올 때 까지 기다린다
    4. 클라이언트로부터 다음 Fetch Call이 오면 1~3 과정을 반복한다 물론, 두 번째 Fetch Call 에서는 ‘D’ 구간부터 읽기 시작한다
- 이처럼 인덱스를 이용해 Nosort 방식으로 Group By를 처리하면 부분범위 처리가 가능해진다
